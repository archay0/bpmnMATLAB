var sourceData4 = {"FileName":"C:\\Users\\Archay wakodikar\\Documents\\MATLAB\\src\\BPMNLayoutOptimizer.m","RawFileContents":["classdef BPMNLayoutOptimizer < handle\r","    % BPMNLayoutOptimizer - Klasse zur Optimierung des Layouts von BPMN-Diagrammen\r","    %\r","    % Diese Klasse implementiert verschiedene Algorithmen zur Optimierung des Layouts\r","    % von BPMN-Diagrammen, einschließlich Kreuzungsminimierung, Abstandsoptimierung\r","    % und Ausrichtungsfunktionen.\r","    \r","    properties\r","        diagram         % Referenz zum BPMN-Diagramm\r","        optimizeOptions % Optionen für die Optimierung\r","    end\r","    \r","    methods\r","        function obj = BPMNLayoutOptimizer(diagram, options)\r","            % Konstruktor für den BPMNLayoutOptimizer\r","            %\r","            % Eingabe:\r","            %   diagram - BPMN-Diagramm Objekt\r","            %   options - Struct mit Optimierungsoptionen (optional)\r","            \r","            obj.diagram = diagram;\r","            \r","            % Standardoptionen setzen\r","            defaultOptions = struct(...\r","                'minNodeDistance', 50, ...\r","                'layerSpacing', 100, ...\r","                'optimizeCrossings', true, ...\r","                'alignGateways', true, ...\r","                'centerActivities', true, ...\r","                'smartEdgeRouting', true, ...\r","                'avoidElementOverlap', true, ...  % Neue Option\r","                'optimizeFlowPaths', true);       % Neue Option\r","            \r","            % Wenn Optionen bereitgestellt wurden, überschreiben Sie die Standardwerte\r","            if nargin > 1 && ~isempty(options)\r","                optFields = fieldnames(options);\r","                for i = 1:length(optFields)\r","                    defaultOptions.(optFields{i}) = options.(optFields{i});\r","                end\r","            end\r","            \r","            obj.optimizeOptions = defaultOptions;\r","        end\r","        \r","        function optimizedDiagram = optimizeAll(obj)\r","            % Optimiert das gesamte Diagramm-Layout\r","            %\r","            % Rückgabe:\r","            %   optimizedDiagram - Das optimierte Diagramm\r","            \r","            % Layers erstellen und Elemente zuweisen\r","            layers = obj.assignElementsToLayers();\r","            \r","            % Minimiere Kreuzungen zwischen den Schichten\r","            if obj.optimizeOptions.optimizeCrossings\r","                layers = obj.minimizeCrossings(layers);\r","            end\r","            \r","            % Positioniere Elemente basierend auf den optimierten Schichten\r","            obj.positionElements(layers);\r","            \r","            % Richte Gateways aus\r","            if obj.optimizeOptions.alignGateways\r","                obj.alignGateways();\r","            end\r","            \r","            % Zentriere Aktivitäten\r","            if obj.optimizeOptions.centerActivities\r","                obj.centerActivities();\r","            end\r","            \r","            % Vermeide Elementüberlappungen - neue Funktion\r","            if obj.optimizeOptions.avoidElementOverlap\r","                obj.resolveElementOverlaps();\r","            end\r","            \r","            % Optimiere Edge-Routing\r","            if obj.optimizeOptions.smartEdgeRouting\r","                obj.routeEdges();\r","            end\r","            \r","            % Optimiere Flusswege - neue Funktion\r","            if obj.optimizeOptions.optimizeFlowPaths\r","                obj.optimizeFlowPaths();\r","            end\r","            \r","            optimizedDiagram = obj.diagram;\r","        end\r","        \r","        function layers = assignElementsToLayers(obj)\r","            % Weist Elemente zu Schichten basierend auf der Prozessflussrichtung zu\r","            %\r","            % Rückgabe:\r","            %   layers - Cell-Array mit Elementgruppen pro Schicht\r","            \r","            % Implementierung eines einfachen Layering-Algorithmus\r","            elements = obj.diagram.elements;\r","            flows = obj.diagram.flows;\r","            \r","            % Finde Start-Events als Ausgangspunkt\r","            startElements = {};\r","            for i = 1:length(elements)\r","                if strcmpi(elements{i}.type, 'startEvent')\r","                    startElements{end+1} = elements{i}; %#ok<AGROW>\r","                end\r","            end\r","            \r","            % Wenn keine Start-Events gefunden, nehmen wir beliebige Elemente ohne eingehende Flows\r","            if isempty(startElements)\r","                nodesWithoutIncoming = obj.findNodesWithoutIncomingFlows();\r","                startElements = nodesWithoutIncoming;\r","            end\r","            \r","            % Initialisiere layers\r","            layers = {};\r","            currentLayer = 1;\r","            layers{currentLayer} = startElements;\r","            \r","            processedElements = {};\r","            \r","            % Iterative Zuweisung von Elementen zu Schichten\r","            while ~isempty(layers{currentLayer})\r","                nextLayer = {};\r","                \r","                for i = 1:length(layers{currentLayer})\r","                    currentElement = layers{currentLayer}{i};\r","                    processedElements{end+1} = currentElement.id; %#ok<AGROW>\r","                    \r","                    % Finde alle ausgehenden Flows und deren Ziele\r","                    for j = 1:length(flows)\r","                        if strcmp(flows{j}.sourceRef, currentElement.id)\r","                            targetId = flows{j}.targetRef;\r","                            \r","                            % Finde das Zielelement\r","                            targetElement = obj.findElementById(targetId);\r","                            \r","                            % Prüfe ob das Zielelement bereits verarbeitet wurde\r","                            if ~isempty(targetElement) && ~ismember(targetId, processedElements)\r","                                % Prüfe ob alle Quellen bereits verarbeitet wurden\r","                                allSourcesProcessed = true;\r","                                \r","                                for k = 1:length(flows)\r","                                    if strcmp(flows{k}.targetRef, targetId) && ...\r","                                            ~strcmp(flows{k}.sourceRef, currentElement.id) && ...\r","                                            ~ismember(flows{k}.sourceRef, processedElements)\r","                                        allSourcesProcessed = false;\r","                                        break;\r","                                    end\r","                                end\r","                                \r","                                % Füge das Element nur hinzu, wenn alle Quellen verarbeitet wurden\r","                                if allSourcesProcessed && ~obj.isElementInAnyLayer(nextLayer, targetElement)\r","                                    nextLayer{end+1} = targetElement; %#ok<AGROW>\r","                                end\r","                            end\r","                        end\r","                    end\r","                end\r","                \r","                currentLayer = currentLayer + 1;\r","                if ~isempty(nextLayer)\r","                    layers{currentLayer} = nextLayer;\r","                else\r","                    break;\r","                end\r","            end\r","        end\r","        \r","        function nodesWithoutIncoming = findNodesWithoutIncomingFlows(obj)\r","            % Findet Elemente ohne eingehende Flows\r","            elements = obj.diagram.elements;\r","            flows = obj.diagram.flows;\r","            \r","            nodesWithoutIncoming = {};\r","            \r","            for i = 1:length(elements)\r","                hasIncoming = false;\r","                \r","                for j = 1:length(flows)\r","                    if strcmp(flows{j}.targetRef, elements{i}.id)\r","                        hasIncoming = true;\r","                        break;\r","                    end\r","                end\r","                \r","                if ~hasIncoming\r","                    nodesWithoutIncoming{end+1} = elements{i}; %#ok<AGROW>\r","                end\r","            end\r","        end\r","        \r","        function element = findElementById(obj, id)\r","            % Findet ein Element durch seine ID\r","            elements = obj.diagram.elements;\r","            element = [];\r","            \r","            for i = 1:length(elements)\r","                if strcmp(elements{i}.id, id)\r","                    element = elements{i};\r","                    return;\r","                end\r","            end\r","        end\r","        \r","        function result = isElementInAnyLayer(~, layer, element)\r","            % Prüft, ob ein Element bereits in einer Schicht enthalten ist\r","            result = false;\r","            \r","            if isempty(layer)\r","                return;\r","            end\r","            \r","            for i = 1:length(layer)\r","                if strcmp(layer{i}.id, element.id)\r","                    result = true;\r","                    return;\r","                end\r","            end\r","        end\r","        \r","        function layers = minimizeCrossings(obj, layers)\r","            % Minimiert Kreuzungen zwischen den Schichten\r","            %\r","            % Eingabe/Rückgabe:\r","            %   layers - Cell-Array mit Elementgruppen pro Schicht\r","            \r","            % Einfacher Algorithmus zur Kreuzungsminimierung\r","            % Für jede Schicht werden Elemente basierend auf Verbindungen umsortiert\r","            \r","            for i = 2:length(layers)\r","                if length(layers{i}) > 1\r","                    % Bestimme die optimale Reihenfolge basierend auf Verbindungen\r","                    % zur vorherigen Schicht\r","                    \r","                    % Ein einfacher Ansatz: Ordne die Elemente nach der Position ihrer\r","                    % Quellen in der vorherigen Schicht\r","                    \r","                    % Erstelle eine Liste von [Element, gewichtete Position]\r","                    elementPositions = cell(1, length(layers{i}));\r","                    flows = obj.diagram.flows;\r","                    \r","                    for j = 1:length(layers{i})\r","                        currentElement = layers{i}{j};\r","                        incomingPositionSum = 0;\r","                        incomingCount = 0;\r","                        \r","                        % Finde alle eingehenden Flüsse von der vorherigen Schicht\r","                        for k = 1:length(flows)\r","                            if strcmp(flows{k}.targetRef, currentElement.id)\r","                                % Finde die Position der Quelle in der vorherigen Schicht\r","                                sourceElement = obj.findElementById(flows{k}.sourceRef);\r","                                if ~isempty(sourceElement)\r","                                    for l = 1:length(layers{i-1})\r","                                        if strcmp(layers{i-1}{l}.id, sourceElement.id)\r","                                            incomingPositionSum = incomingPositionSum + l;\r","                                            incomingCount = incomingCount + 1;\r","                                            break;\r","                                        end\r","                                    end\r","                                end\r","                            end\r","                        end\r","                        \r","                        % Berechne den durchschnittlichen Positionswert\r","                        avgPosition = incomingCount > 0 ? incomingPositionSum / incomingCount : j;\r","                        elementPositions{j} = {currentElement, avgPosition};\r","                    end\r","                    \r","                    % Sortiere die Elemente nach ihrer durchschnittlichen Position\r","                    positionValues = cellfun(@(x) x{2}, elementPositions);\r","                    [~, sortIdx] = sort(positionValues);\r","                    \r","                    % Sortiere die Schicht neu\r","                    sortedLayer = cell(1, length(layers{i}));\r","                    for j = 1:length(sortIdx)\r","                        sortedLayer{j} = elementPositions{sortIdx(j)}{1};\r","                    end\r","                    \r","                    layers{i} = sortedLayer;\r","                end\r","            end\r","        end\r","        \r","        function positionElements(obj, layers)\r","            % Positioniert Elemente basierend auf den optimierten Schichten\r","            \r","            % Grundlegende Konfiguration\r","            layerHeight = obj.optimizeOptions.layerSpacing;\r","            elementWidth = 100;  % Standard Elementbreite\r","            elementHeight = 80;  % Standard Elementhöhe\r","            marginX = obj.optimizeOptions.minNodeDistance;\r","            startX = 50;\r","            startY = 50;\r","            \r","            % Positioniere jedes Element basierend auf seiner Schicht\r","            for i = 1:length(layers)\r","                currentY = startY + (i-1) * layerHeight;\r","                layerWidth = (length(layers{i}) - 1) * (elementWidth + marginX);\r","                currentX = startX;\r","                \r","                for j = 1:length(layers{i})\r","                    element = layers{i}{j};\r","                    \r","                    % Anpassen der Elementgröße je nach Typ\r","                    if strcmpi(element.type, 'task')\r","                        w = 100;\r","                        h = 80;\r","                    elseif strcmpi(element.type, 'gateway')\r","                        w = 50;\r","                        h = 50;\r","                    elseif any(strcmpi(element.type, {'startEvent', 'endEvent', 'intermediateEvent'}))\r","                        w = 40;\r","                        h = 40;\r","                    else\r","                        w = elementWidth;\r","                        h = elementHeight;\r","                    end\r","                    \r","                    % Element positionieren\r","                    element.x = currentX;\r","                    element.y = currentY;\r","                    element.width = w;\r","                    element.height = h;\r","                    \r","                    % Aktualisiere die X-Position für das nächste Element\r","                    currentX = currentX + w + marginX;\r","                end\r","            end\r","            \r","            % Nachbearbeitung: Zentriere Elemente in jeder Schicht\r","            for i = 1:length(layers)\r","                if ~isempty(layers{i})\r","                    totalWidth = layers{i}{end}.x + layers{i}{end}.width - layers{i}{1}.x;\r","                    centerOffset = (layerWidth - totalWidth) / 2;\r","                    \r","                    if centerOffset > 0\r","                        for j = 1:length(layers{i})\r","                            layers{i}{j}.x = layers{i}{j}.x + centerOffset;\r","                        end\r","                    end\r","                end\r","            end\r","        end\r","        \r","        function alignGateways(obj)\r","            % Richtet Gateways vertikal aus\r","            \r","            elements = obj.diagram.elements;\r","            \r","            % Gruppieren Sie Gateways nach Typ\r","            gateways = {};\r","            for i = 1:length(elements)\r","                if strcmpi(elements{i}.type, 'exclusiveGateway') || ...\r","                   strcmpi(elements{i}.type, 'parallelGateway') || ...\r","                   strcmpi(elements{i}.type, 'inclusiveGateway')\r","                    gateways{end+1} = elements{i}; %#ok<AGROW>\r","                end\r","            end\r","            \r","            % Finde ähnliche Gateway-Gruppen (z.B. Split/Join-Paare)\r","            if length(gateways) > 1\r","                for i = 1:length(gateways)-1\r","                    for j = i+1:length(gateways)\r","                        % Wenn Gateways auf unterschiedlichen Ebenen sind (unterschiedliche Y-Werte)\r","                        % aber vom gleichen Typ, versuchen Sie, sie vertikal auszurichten\r","                        if abs(gateways{i}.y - gateways{j}.y) > gateways{i}.height && ...\r","                           strcmpi(gateways{i}.type, gateways{j}.type)\r","                            \r","                            % Berechnen Sie die mittlere X-Position\r","                            avgX = (gateways{i}.x + gateways{j}.x) / 2;\r","                            \r","                            % Alinieren beide zu dieser Position\r","                            gateways{i}.x = avgX;\r","                            gateways{j}.x = avgX;\r","                        end\r","                    end\r","                end\r","            end\r","        end\r","        \r","        function centerActivities(obj)\r","            % Zentriert Aktivitäten innerhalb ihrer Verbindungen\r","            \r","            elements = obj.diagram.elements;\r","            flows = obj.diagram.flows;\r","            \r","            for i = 1:length(elements)\r","                if strcmpi(elements{i}.type, 'task')\r","                    % Finde alle ein- und ausgehenden Flows für diese Aktivität\r","                    incomingFlows = {};\r","                    outgoingFlows = {};\r","                    \r","                    for j = 1:length(flows)\r","                        if strcmp(flows{j}.targetRef, elements{i}.id)\r","                            incomingFlows{end+1} = flows{j}; %#ok<AGROW>\r","                        elseif strcmp(flows{j}.sourceRef, elements{i}.id)\r","                            outgoingFlows{end+1} = flows{j}; %#ok<AGROW>\r","                        end\r","                    end\r","                    \r","                    % Berechne durchschnittliche X-Position der verbundenen Elemente\r","                    sumX = 0;\r","                    count = 0;\r","                    \r","                    for j = 1:length(incomingFlows)\r","                        sourceElement = obj.findElementById(incomingFlows{j}.sourceRef);\r","                        if ~isempty(sourceElement)\r","                            sumX = sumX + sourceElement.x + sourceElement.width/2;\r","                            count = count + 1;\r","                        end\r","                    end\r","                    \r","                    for j = 1:length(outgoingFlows)\r","                        targetElement = obj.findElementById(outgoingFlows{j}.targetRef);\r","                        if ~isempty(targetElement)\r","                            sumX = sumX + targetElement.x + targetElement.width/2;\r","                            count = count + 1;\r","                        end\r","                    end\r","                    \r","                    % Wenn es verbundene Elemente gibt, zentriere die Aktivität\r","                    if count > 0\r","                        avgX = sumX / count;\r","                        elements{i}.x = avgX - elements{i}.width/2;\r","                    end\r","                end\r","            end\r","        end\r","        \r","        function routeEdges(obj)\r","            % Implementiert intelligentes Edge-Routing für Sequenzflüsse\r","            \r","            flows = obj.diagram.flows;\r","            \r","            for i = 1:length(flows)\r","                sourceElement = obj.findElementById(flows{i}.sourceRef);\r","                targetElement = obj.findElementById(flows{i}.targetRef);\r","                \r","                if ~isempty(sourceElement) && ~isempty(targetElement)\r","                    % Berechne Wegpunkte für den Flow\r","                    waypoints = obj.calculateWaypoints(sourceElement, targetElement);\r","                    flows{i}.waypoints = waypoints;\r","                end\r","            end\r","        end\r","        \r","        function waypoints = calculateWaypoints(obj, source, target)\r","            % Berechnet Wegpunkte für einen Flow zwischen zwei Elementen\r","            \r","            % Einfacher Algorithmus für gerade Linien mit zwei Punkten\r","            % Ausgangspunkt (vom Quell-Element)\r","            sourceX = source.x + source.width/2;\r","            sourceY = source.y + source.height/2;\r","            \r","            % Zielpunkt (zum Ziel-Element)\r","            targetX = target.x + target.width/2;\r","            targetY = target.y + target.height/2;\r","            \r","            % Für komplexere Routen könnten hier zusätzliche Wegpunkte eingefügt werden\r","            \r","            % Einfacher Fall: direkte Verbindung (für nähere Elemente)\r","            if abs(targetY - sourceY) < obj.optimizeOptions.layerSpacing * 1.5\r","                waypoints = [sourceX, sourceY; targetX, targetY];\r","                return;\r","            end\r","            \r","            % Komplexerer Fall: 3-Punkt-Verbindung (für weiter entfernte Elemente)\r","            % Mittelpunkt zur Vermeidung von Überschneidungen\r","            midY = (sourceY + targetY) / 2;\r","            waypoints = [sourceX, sourceY; sourceX, midY; targetX, midY; targetX, targetY];\r","        end\r","        \r","        function resolveElementOverlaps(obj)\r","            % Erkennt und löst überlappende Elemente im Diagramm\r","            \r","            elements = obj.diagram.elements;\r","            modified = true;\r","            \r","            % Iterationen fortsetzen, bis keine Überlappungen mehr gelöst werden\r","            iterationCount = 0;\r","            maxIterations = 10; % Begrenzung der Iterationen zur Vermeidung von Endlosschleifen\r","            \r","            while modified && iterationCount < maxIterations\r","                modified = false;\r","                iterationCount = iterationCount + 1;\r","                \r","                % Überprüfen Sie jedes Elementpaar auf Überlappung\r","                for i = 1:length(elements)\r","                    for j = i+1:length(elements)\r","                        % Berechne Begrenzungsrahmen\r","                        box1 = [elements{i}.x, elements{i}.y, ...\r","                               elements{i}.x + elements{i}.width, ...\r","                               elements{i}.y + elements{i}.height];\r","                           \r","                        box2 = [elements{j}.x, elements{j}.y, ...\r","                               elements{j}.x + elements{j}.width, ...\r","                               elements{j}.y + elements{j}.height];\r","                        \r","                        % Überprüfen Sie auf Überlappung\r","                        if obj.boxesOverlap(box1, box2)\r","                            % Berechne Überlappungsmenge\r","                            overlapX = min(box1(3), box2(3)) - max(box1(1), box2(1));\r","                            overlapY = min(box1(4), box2(4)) - max(box1(2), box2(2));\r","                            \r","                            % Bestimmen Sie die Schubrichtung basierend auf der kleinsten Überlappung\r","                            if overlapX < overlapY\r","                                % Horizontal schieben\r","                                if box1(1) < box2(1)\r","                                    elements{j}.x = elements{j}.x + overlapX + obj.optimizeOptions.minNodeDistance/4;\r","                                else\r","                                    elements{i}.x = elements{i}.x + overlapX + obj.optimizeOptions.minNodeDistance/4;\r","                                end\r","                            else\r","                                % Vertikal schieben, nur wenn Elemente nicht auf derselben Schicht sind\r","                                % um die Flussstruktur beizubehalten\r","                                if abs(elements{i}.y - elements{j}.y) > obj.optimizeOptions.minNodeDistance\r","                                    if box1(2) < box2(2)\r","                                        elements{j}.y = elements{j}.y + overlapY + obj.optimizeOptions.minNodeDistance/4;\r","                                    else\r","                                        elements{i}.y = elements{i}.y + overlapY + obj.optimizeOptions.minNodeDistance/4;\r","                                    end\r","                                else\r","                                    % Für Elemente auf derselben Schicht horizontal schieben\r","                                    separation = obj.optimizeOptions.minNodeDistance + max(elements{i}.width, elements{j}.width)/2;\r","                                    if box1(1) < box2(1)\r","                                        elements{j}.x = elements{i}.x + separation;\r","                                    else\r","                                        elements{i}.x = elements{j}.x + separation;\r","                                    end\r","                                end\r","                            end\r","                            \r","                            modified = true;\r","                        end\r","                    end\r","                end\r","            end\r","            \r","            % Nach dem Lösen von Überlappungen sicherstellen, dass Elemente den Mindestabstand einhalten\r","            for i = 1:length(elements)\r","                for j = i+1:length(elements)\r","                    % Überprüfen Sie nur Elemente in derselben ungefähren vertikalen Position (gleiche Schicht)\r","                    if abs(elements{i}.y - elements{j}.y) < obj.optimizeOptions.minNodeDistance\r","                        % Überprüfen Sie den horizontalen Abstand\r","                        if abs(elements{i}.x - elements{j}.x) < obj.optimizeOptions.minNodeDistance\r","                            % Positionen anpassen, um den Mindestabstand einzuhalten\r","                            if elements{i}.x < elements{j}.x\r","                                elements{j}.x = elements{i}.x + elements{i}.width + obj.optimizeOptions.minNodeDistance;\r","                            else\r","                                elements{i}.x = elements{j}.x + elements{j}.width + obj.optimizeOptions.minNodeDistance;\r","                            end\r","                        end\r","                    end\r","                end\r","            end\r","        end\r","        \r","        function overlap = boxesOverlap(~, box1, box2)\r","            % Bestimmt, ob sich zwei Begrenzungsrahmen überlappen\r","            % Box-Format: [x1, y1, x2, y2] (obere linke und untere rechte Ecken)\r","            \r","            % Überprüfen Sie, ob eine Box vollständig links/rechts/oben/unten der anderen liegt\r","            if box1(3) < box2(1) || box2(3) < box1(1) || ...\r","               box1(4) < box2(2) || box2(4) < box1(2)\r","                overlap = false;\r","            else\r","                overlap = true;\r","            end\r","        end\r","        \r","        function optimizeFlowPaths(obj)\r","            % Optimiert Flusswege zur Verbesserung der Diagrammlesbarkeit\r","            \r","            flows = obj.diagram.flows;\r","            \r","            for i = 1:length(flows)\r","                sourceElement = obj.findElementById(flows{i}.sourceRef);\r","                targetElement = obj.findElementById(flows{i}.targetRef);\r","                \r","                if ~isempty(sourceElement) && ~isempty(targetElement)\r","                    % Berechne den optimalen Pfad zwischen den Elementen mit A* oder ähnlichem Algorithmus\r","                    flows{i}.waypoints = obj.calculateOptimalPath(sourceElement, targetElement);\r","                end\r","            end\r","            \r","            % Erkennen und Lösen von Flusskreuzungen, wo möglich\r","            obj.reduceFlowCrossings();\r","        end\r","        \r","        function waypoints = calculateOptimalPath(obj, source, target)\r","            % Berechnet einen optimalen Pfad zwischen zwei Elementen mit verbesserter Wegpunktberechnung\r","            \r","            % Ausgangsposition (Mitte des Quell-Elements)\r","            sourceX = source.x + source.width/2;\r","            sourceY = source.y + source.height/2;\r","            \r","            % Zielposition (Mitte des Ziel-Elements)\r","            targetX = target.x + target.width/2;\r","            targetY = target.y + target.height/2;\r","            \r","            % Überprüfen, ob Quelle und Ziel nahe beieinander liegen\r","            if abs(sourceY - targetY) < obj.optimizeOptions.layerSpacing/2 && ...\r","               abs(sourceX - targetX) < obj.optimizeOptions.minNodeDistance*3\r","                % Direkte Verbindung für eng positionierte Elemente\r","                waypoints = [sourceX, sourceY; targetX, targetY];\r","                return;\r","            end\r","            \r","            % Verbesserter Mehrpunktpfad für komplexe Routing-Szenarien\r","            \r","            % Berechnen, ob eine vertikale oder horizontale Beziehung besteht\r","            isVerticalFlow = abs(sourceY - targetY) > abs(sourceX - targetX);\r","            \r","            if isVerticalFlow\r","                % Primär vertikaler Flusspfad\r","                midY = (sourceY + targetY) / 2;\r","                \r","                % Überprüfen auf potenzielle Routing-Interferenzen mit anderen Elementen\r","                if obj.pathIntersectsElements(sourceX, sourceY, sourceX, midY) || ...\r","                   obj.pathIntersectsElements(sourceX, midY, targetX, midY) || ...\r","                   obj.pathIntersectsElements(targetX, midY, targetX, targetY)\r","                   \r","                    % Pfad anpassen zur Vermeidung von Interferenzen\r","                    alternativeMidX = (sourceX + targetX) / 2;\r","                    waypoints = [sourceX, sourceY; \r","                                alternativeMidX, sourceY;\r","                                alternativeMidX, targetY; \r","                                targetX, targetY];\r","                else\r","                    % Standard vertikaler Routing-Pfad\r","                    waypoints = [sourceX, sourceY; \r","                                sourceX, midY; \r","                                targetX, midY; \r","                                targetX, targetY];\r","                end\r","            else\r","                % Primär horizontaler Flusspfad\r","                midX = (sourceX + targetX) / 2;\r","                \r","                % Überprüfen auf potenzielle Routing-Interferenzen\r","                if obj.pathIntersectsElements(sourceX, sourceY, midX, sourceY) || ...\r","                   obj.pathIntersectsElements(midX, sourceY, midX, targetY) || ...\r","                   obj.pathIntersectsElements(midX, targetY, targetX, targetY)\r","                   \r","                    % Pfad anpassen zur Vermeidung von Interferenzen\r","                    alternativeMidY = (sourceY + targetY) / 2;\r","                    waypoints = [sourceX, sourceY; \r","                                sourceX, alternativeMidY;\r","                                targetX, alternativeMidY; \r","                                targetX, targetY];\r","                else\r","                    % Standard horizontaler Routing-Pfad\r","                    waypoints = [sourceX, sourceY; \r","                                midX, sourceY; \r","                                midX, targetY; \r","                                targetX, targetY];\r","                end\r","            end\r","        end\r","        \r","        function intersects = pathIntersectsElements(obj, x1, y1, x2, y2)\r","            % Überprüft, ob ein Pfadsegment mit einem Element kollidiert\r","            \r","            elements = obj.diagram.elements;\r","            intersects = false;\r","            \r","            % Pfadsegment als Linie\r","            linePath = [x1, y1, x2, y2];\r","            \r","            % Pufferabstand, um zu verhindern, dass zu nahe an Elementen geroutet wird\r","            buffer = 5;\r","            \r","            for i = 1:length(elements)\r","                element = elements{i};\r","                \r","                % Überspringen von Quell- und Zielelementen oder sehr kleinen Elementen\r","                if (abs(element.x + element.width/2 - x1) < 1e-6 && \r","                    abs(element.y + element.height/2 - y1) < 1e-6) || ...\r","                   (abs(element.x + element.width/2 - x2) < 1e-6 && \r","                    abs(element.y + element.height/2 - y2) < 1e-6)\r","                    continue;\r","                end\r","                \r","                % Begrenzungsrahmen des Elements mit Puffer\r","                bbox = [element.x - buffer, element.y - buffer, \r","                        element.x + element.width + buffer, element.y + element.height + buffer];\r","                \r","                % Überprüfen, ob die Linie den Begrenzungsrahmen des Elements schneidet\r","                if obj.lineIntersectsBox(linePath, bbox)\r","                    intersects = true;\r","                    return;\r","                end\r","            end\r","        end\r","        \r","        function intersects = lineIntersectsBox(~, line, box)\r","            % Bestimmt, ob ein Liniensegment mit einer Box kollidiert\r","            % Linienformat: [x1, y1, x2, y2]\r","            % Box-Format: [x1, y1, x2, y2] (obere linke und untere rechte Ecken)\r","            \r","            % Liniensegmentparameter\r","            x1 = line(1); y1 = line(2);\r","            x2 = line(3); y2 = line(4);\r","            \r","            % Box-Grenzen\r","            left = box(1); top = box(2);\r","            right = box(3); bottom = box(4);\r","            \r","            % Cohen-Sutherland-Algorithmus zur Linien-Rechteck-Kollision\r","            INSIDE = 0; % 0000\r","            LEFT = 1;   % 0001\r","            RIGHT = 2;  % 0010\r","            BOTTOM = 4; % 0100\r","            TOP = 8;    % 1000\r","            \r","            % Berechnen der Outcodes\r","            function code = computeOutCode(x, y)\r","                code = INSIDE;\r","                if x < left\r","                    code = bitor(code, LEFT);\r","                elseif x > right\r","                    code = bitor(code, RIGHT);\r","                end\r","                if y < top\r","                    code = bitor(code, TOP);\r","                elseif y > bottom\r","                    code = bitor(code, BOTTOM);\r","                end\r","            end\r","            \r","            outcode1 = computeOutCode(x1, y1);\r","            outcode2 = computeOutCode(x2, y2);\r","            \r","            while true\r","                % Beide Endpunkte sind innerhalb der Box - triviale Akzeptanz\r","                if outcode1 == 0 && outcode2 == 0\r","                    intersects = true;\r","                    return;\r","                end\r","                \r","                % Linie ist vollständig außerhalb der Box - triviale Ablehnung\r","                if bitand(outcode1, outcode2) ~= 0\r","                    intersects = false;\r","                    return;\r","                end\r","                \r","                % Ein Teil der Linie könnte innerhalb sein - Schnittpunkt berechnen\r","                x = 0; y = 0;\r","                outcodeOut = max(outcode1, outcode2);\r","                \r","                % Schnittpunkt finden\r","                if bitand(outcodeOut, TOP) ~= 0\r","                    x = x1 + (x2 - x1) * (top - y1) / (y2 - y1);\r","                    y = top;\r","                elseif bitand(outcodeOut, BOTTOM) ~= 0\r","                    x = x1 + (x2 - x1) * (bottom - y1) / (y2 - y1);\r","                    y = bottom;\r","                elseif bitand(outcodeOut, RIGHT) ~= 0\r","                    y = y1 + (y2 - y1) * (right - x1) / (x2 - x1);\r","                    x = right;\r","                elseif bitand(outcodeOut, LEFT) ~= 0\r","                    y = y1 + (y2 - y1) * (left - x1) / (x2 - x1);\r","                    x = left;\r","                end\r","                \r","                % Endpunkte aktualisieren\r","                if outcodeOut == outcode1\r","                    x1 = x; y1 = y;\r","                    outcode1 = computeOutCode(x1, y1);\r","                else\r","                    x2 = x; y2 = y;\r","                    outcode2 = computeOutCode(x2, y2);\r","                end\r","            end\r","        end\r","        \r","        function reduceFlowCrossings(obj)\r","            % Versucht, Flusskreuzungen durch Anpassen der Wegpunkte zu reduzieren\r","            \r","            flows = obj.diagram.flows;\r","            \r","            % Flusskreuzungen identifizieren\r","            for i = 1:length(flows)-1\r","                for j = i+1:length(flows)\r","                    if isfield(flows{i}, 'waypoints') && isfield(flows{j}, 'waypoints')\r","                        % Überprüfen, ob diese Flüsse sich kreuzen\r","                        crossingPoints = obj.findFlowCrossings(flows{i}, flows{j});\r","                        \r","                        if ~isempty(crossingPoints)\r","                            % Versuchen, die Kreuzung durch Anpassen der Wegpunkte zu lösen\r","                            [flows{i}, flows{j}] = obj.resolveCrossing(flows{i}, flows{j}, crossingPoints);\r","                        end\r","                    end\r","                end\r","            end\r","        end\r","        \r","        function crossingPoints = findFlowCrossings(~, flow1, flow2)\r","            % Identifiziert Kreuzungspunkte zwischen zwei Flüssen\r","            \r","            crossingPoints = [];\r","            \r","            if ~isfield(flow1, 'waypoints') || ~isfield(flow2, 'waypoints') || ...\r","               size(flow1.waypoints, 1) < 2 || size(flow2.waypoints, 1) < 2\r","                return;\r","            end\r","            \r","            % Überprüfen Sie jedes Segment von flow1 gegen jedes Segment von flow2\r","            for i = 1:size(flow1.waypoints, 1)-1\r","                seg1 = [flow1.waypoints(i,:), flow1.waypoints(i+1,:)];\r","                \r","                for j = 1:size(flow2.waypoints, 1)-1\r","                    seg2 = [flow2.waypoints(j,:), flow2.waypoints(j+1,:)];\r","                    \r","                    % Überprüfen, ob Segmente sich schneiden\r","                    [intersect, x, y] = obj.lineSegmentIntersection(seg1, seg2);\r","                    \r","                    if intersect\r","                        crossingPoints(end+1,:) = [x, y, i, j]; %#ok<AGROW>\r","                    end\r","                end\r","            end\r","        end\r","        \r","        function [intersect, x, y] = lineSegmentIntersection(~, seg1, seg2)\r","            % Bestimmt, ob sich zwei Liniensegmente schneiden\r","            \r","            x1 = seg1(1); y1 = seg1(2);\r","            x2 = seg1(3); y2 = seg1(4);\r","            \r","            x3 = seg2(1); y3 = seg2(2);\r","            x4 = seg2(3); y4 = seg2(4);\r","            \r","            % Berechnen des Nenners\r","            den = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1);\r","            \r","            % Überprüfen, ob Linien parallel sind\r","            if abs(den) < 1e-10\r","                intersect = false;\r","                x = 0; y = 0;\r","                return;\r","            end\r","            \r","            % Berechnen der Zähler\r","            numa = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3));\r","            numb = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3));\r","            \r","            % Berechnen der Parameter\r","            ua = numa / den;\r","            ub = numb / den;\r","            \r","            % Wenn Parameter in [0,1] liegen, schneiden sich die Segmente\r","            if ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1\r","                % Berechnen des Schnittpunkts\r","                x = x1 + ua * (x2 - x1);\r","                y = y1 + ua * (y2 - y1);\r","                intersect = true;\r","            else\r","                intersect = false;\r","                x = 0; y = 0;\r","            end\r","        end\r","        \r","        function [flow1, flow2] = resolveCrossing(obj, flow1, flow2, crossingPoints)\r","            % Versucht, die Kreuzung zwischen zwei Flüssen durch Ändern der Wegpunkte zu lösen\r","            \r","            if isempty(crossingPoints)\r","                return;\r","            end\r","            \r","            % Erhalten Sie den Kreuzungspunkt und die Segmentindizes\r","            crossingX = crossingPoints(1,1);\r","            crossingY = crossingPoints(1,2);\r","            seg1Idx = crossingPoints(1,3);\r","            seg2Idx = crossingPoints(1,4);\r","            \r","            % Berechnen des Versatzabstands\r","            offset = obj.optimizeOptions.minNodeDistance / 2;\r","            \r","            % Bestimmen, welcher Fluss basierend auf ihren Typen und ihrer Wichtigkeit angepasst werden soll\r","            source1 = obj.findElementById(flow1.sourceRef);\r","            source2 = obj.findElementById(flow2.sourceRef);\r","            \r","            if isempty(source1) || isempty(source2)\r","                return;\r","            end\r","            \r","            % Priorisieren Sie die Anpassung normaler Sequenzflüsse gegenüber Nachrichtenflüssen oder Assoziationen\r","            isFlow1SequenceFlow = strcmp(flow1.type, 'sequenceFlow');\r","            isFlow2SequenceFlow = strcmp(flow2.type, 'sequenceFlow');\r","            \r","            if isFlow1SequenceFlow && ~isFlow2SequenceFlow\r","                % Fluss2 anpassen\r","                flow2.waypoints = obj.insertWaypointOffset(flow2.waypoints, seg2Idx, offset);\r","            elseif ~isFlow1SequenceFlow && isFlow2SequenceFlow\r","                % Fluss1 anpassen\r","                flow1.waypoints = obj.insertWaypointOffset(flow1.waypoints, seg1Idx, offset);\r","            else\r","                % Beide sind vom gleichen Typ, den kürzeren anpassen\r","                length1 = size(flow1.waypoints, 1);\r","                length2 = size(flow2.waypoints, 1);\r","                \r","                if length1 <= length2\r","                    flow1.waypoints = obj.insertWaypointOffset(flow1.waypoints, seg1Idx, offset);\r","                else\r","                    flow2.waypoints = obj.insertWaypointOffset(flow2.waypoints, seg2Idx, offset);\r","                end\r","            end\r","        end\r","        \r","        function waypoints = insertWaypointOffset(~, waypoints, segmentIdx, offset)\r","            % Fügt einen Versatz in einen Flusspfad ein, um eine Kreuzung zu vermeiden\r","            \r","            if segmentIdx < 1 || segmentIdx >= size(waypoints, 1)\r","                return;\r","            end\r","            \r","            % Ursprüngliche Segmentpunkte\r","            p1 = waypoints(segmentIdx, :);\r","            p2 = waypoints(segmentIdx+1, :);\r","            \r","            % Berechnen der Segmentrichtung\r","            dx = p2(1) - p1(1);\r","            dy = p2(2) - p1(2);\r","            \r","            % Wenn das Segment mehr horizontal ist, vertikalen Versatz erstellen\r","            if abs(dx) >= abs(dy)\r","                midX = (p1(1) + p2(1)) / 2;\r","                newPoints = [midX, p1(2)+offset; midX, p1(2)-offset];\r","            else\r","                % Wenn das Segment mehr vertikal ist, horizontalen Versatz erstellen\r","                midY = (p1(2) + p2(2)) / 2;\r","                newPoints = [p1(1)+offset, midY; p1(1)-offset, midY];\r","            end\r","            \r","            % Neue Punkte einfügen\r","            waypoints = [waypoints(1:segmentIdx,:); newPoints; waypoints(segmentIdx+1:end,:)];\r","        end\r","    end\r","end"],"CoverageDisplayDataPerLine":{"Function":[],"Statement":[]},"FilterData":[]}